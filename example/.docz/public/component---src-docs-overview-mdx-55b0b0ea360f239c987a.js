(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{v4vX:function(e,o,t){"use strict";t.r(o),t.d(o,"_frontmatter",(function(){return s})),t.d(o,"default",(function(){return d}));t("5hJT"),t("W1QL"),t("K/PF"),t("t91x"),t("75LO"),t("PJhk"),t("mXGw");var n=t("/FXl"),i=t("TjRS"),r=t("OOTA");t("aD51");function a(){return(a=Object.assign||function(e){for(var o=1;o<arguments.length;o++){var t=arguments[o];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}var s={};void 0!==s&&s&&s===Object(s)&&Object.isExtensible(s)&&!s.hasOwnProperty("__filemeta")&&Object.defineProperty(s,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/docs/overview.mdx"}});var l={_frontmatter:s},c=i.a;function d(e){var o=e.components,t=function(e,o){if(null==e)return{};var t,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],o.indexOf(t)>=0||(i[t]=e[t]);return i}(e,["components"]);return Object(n.b)(c,a({},l,t,{components:o,mdxType:"MDXLayout"}),Object(n.b)("h1",{id:"overview"},"Overview"),Object(n.b)("h2",{id:"the-problem"},"The Problem"),Object(n.b)("p",null,"As most apps grow and mature, developers are often faced with an important problem: How to present a user-interface to end-users for customizing business logic. Solving this problem gives rise to a large number of complex, bespoke UIs. This problem becomes especially apparent in apps designed to serve a wide variety of users with unique business logic needs. Flume is an attempt to help developers standardize logic editing around a standard (albeit, customizable) user interface: a node editor."),Object(n.b)("h2",{id:"why-a-node-editor"},"Why a Node Editor?"),Object(n.b)("p",null,'One could argue that node editors have become a standard for visual logic editing. They allow for a wide variety of logical structures, but also allow developers to define their own "guardrails" to prevent end-users from defining invalid logic. In many applications, node editors have become a common compromise between UI complexity, and full logical expression. Following are just a few examples of node editors found in popular desktop applications (Flume itself is inspired by many of these node-editor implementations).'),Object(n.b)("br",null),Object(n.b)(r.a,{center:!0,mdxType:"FlexRow"},Object(n.b)("img",{src:"/public/img/example_editors.png",alt:"A grid of node editor screenshots including, Blender, Unreal Engine, Substance Designer, and GoDot",style:{maxWidth:800}})),Object(n.b)("h2",{id:"logic-extraction"},"Logic Extraction"),Object(n.b)("p",null,"As a side benefit, putting complex business logic into the hands of users, frees developers from the complexity of maintaining complex logic in code. This reduces the surface area for bugs and makes defining business logic accessible for non-programmers in your organization."),Object(n.b)("p",null,"Additionally, because business logic can be stored in JSON structures in your database, business logic can be swapped out in your application remotely without requiring a new build of your application's code."))}void 0!==d&&d&&d===Object(d)&&Object.isExtensible(d)&&!d.hasOwnProperty("__filemeta")&&Object.defineProperty(d,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/docs/overview.mdx"}}),d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-docs-overview-mdx-55b0b0ea360f239c987a.js.map